package lab4;

import java.util.*;

/**

 * Класс игры "Пятнашки"

 */

public class Tags {

    public static final int FIELD_SIZE = 4; // Размер поля 4x4

    private final int[][] field = new int[FIELD_SIZE][FIELD_SIZE]; // Двумерный массив чисел для представления поля игры

    private final Point emptyTagPosition = new Point(FIELD_SIZE - 1, FIELD_SIZE - 1); // Координаты пустой кости

// Конуструктор

    public Tags() {

// Объект создания случайных значений

        var random = new Random();

// Список допустимых значений костей

        var possibleNumbers = generatePossibleNumbers();

// В цикле идём по полю игры

        for (var y = 0; y < FIELD_SIZE; y++) {

            for (var x = 0; x < FIELD_SIZE; x++) {

// Нижний правый квадрат - пустой

                if (y == FIELD_SIZE - 1 && x == FIELD_SIZE - 1) {

                    field[y][x] = 0;

                    continue;

                }

// Случайный индекс для допустимых значений костей

                var index = random.nextInt(possibleNumbers.size());

// Случайное значение кости

                var value = possibleNumbers.get(index);

// Удаляем значение из списка допустимых значений

                possibleNumbers.remove(index);

// Выставляем значение кости на поле

                field[y][x] = value;

            }

        }

    }

    public int[][] getField() { // Получаем поле игры и возвращаем двумерный массив чисел для представления поля игры

        return field;

    }

// Ход игры по направлению.direction - направление. Возвращаем true - игрок выиграл, false - игрок пока не выиграл

    public boolean select(Direction direction) throws Exception {

// Соотносим напрвление с нужной костью относительно пустой кости

        return switch (direction) {

            case UP -> select(new Point(emptyTagPosition.getX(), emptyTagPosition.getY() + 1));

            case DOWN -> select(new Point(emptyTagPosition.getX(), emptyTagPosition.getY() - 1));

            case LEFT -> select(new Point(emptyTagPosition.getX() + 1, emptyTagPosition.getY()));

            case RIGHT -> select(new Point(emptyTagPosition.getX() - 1, emptyTagPosition.getY()));

        };

    }

// Ход игры по координатам выбранной кости. point - координаты кости. Возвращаем true - игрок выиграл, false - игрок пока не выиграл

    public boolean select(Point point) throws Exception {

// Если координаты кости за полем игры, выбрасываем исключение

        if (!(0 <= point.getX() && point.getX() < FIELD_SIZE && 0 <= point.getY() && point.getY() < FIELD_SIZE)) {

            throw new Exception("Out of field");

        }

// Если была выбрана пустая кость, выбрасываем исключение

        if (point.getX() == emptyTagPosition.getX() && point.getY() == emptyTagPosition.getY()) {

            throw new Exception("Cannot choose empty tag");

        }

// Если выбрана не соседняя кость по горизонтали или вертикали, выбрасываем исключение

        if (!(

                (point.getY() == emptyTagPosition.getY() && Math.abs(point.getX() - emptyTagPosition.getX()) == 1) ||

                        (point.getX() == emptyTagPosition.getX() && Math.abs(point.getY() - emptyTagPosition.getY()) == 1)

        )) {

            throw new Exception("Cannot choose tag that not near empty tag by X-axis or Y-axis");

        }

// Временное значение кости для того, чтобы поменять кости местами

        var temp = field[point.getY()][point.getX()];

// Ставим на место выбранной кости пустую кость

        field[point.getY()][point.getX()] = field[emptyTagPosition.getY()][emptyTagPosition.getX()];

// Ставим на место пустой кости выбранную кость

        field[emptyTagPosition.getY()][emptyTagPosition.getX()] = temp;

// Обновляем координаты пустой кости

        emptyTagPosition.setX(point.getX());

        emptyTagPosition.setY(point.getY());

// Возвращаем результат игры

        return isWin();

    }

// Сгенерировать список допустимых значений для костей и вернуть список значений

    private List<Integer> generatePossibleNumbers() {

// Список значений

        var possibleNumbers = new ArrayList<Integer>();

// Добавляем в список числа от 1 до 15 включительно

        for (var i = 0; i < FIELD_SIZE * FIELD_SIZE - 1; i++) {

            possibleNumbers.add(i + 1);

        }

// Возвращаем список

        return possibleNumbers;

    }

// Проверить, выиграл ли игрок. Возвраащем true, если игрок выиграл, и false, если проиграл

    private boolean isWin() {

// Счётчик для проверки на последовательность

        var counter = 1;

// В цикле идём по полю игры

        for (var y = 0; y < FIELD_SIZE; y++) {

            for (var x = 0; x < FIELD_SIZE; x++) {

// Пропускаем нижнюю правую кость

                if (x == FIELD_SIZE - 1 && y == FIELD_SIZE -1) {

                    continue;

                }

// Если значение кости не последовательно, то игрок проиграл

                if (counter != field[y][x]) {

                    return false;

                }

// Добавляем единицу к счётчику

                counter++;

            }

        }

// Раз всё было последовательно, игрок выиграл

        return true;

    }

}
